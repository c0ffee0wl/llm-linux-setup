#!/bin/bash
#
# transcribe - Speech-to-text transcription using faster-whisper
#
# A wrapper around whisper-ctranslate2 with sensible defaults for CPU transcription.
# Supports: mp3, mp4, wav, m4a, flac, ogg, webm (any format supported by ffmpeg)
#
# Usage: transcribe <audio_or_video_file> [options]
#
# Options:
#   -m, --model MODEL    Model to use (default: medium)
#                        Available: tiny, base, small, medium, large-v3, large-v3-turbo
#   -l, --language LANG  Force language (auto-detect by default)
#                        Examples: en, de, fr, es, ja, zh, etc.
#   -f, --format FORMAT  Output format: txt, srt, vtt, json, tsv (default: txt)
#   -o, --output FILE    Output file path (default: <input_basename>.<format>)
#   --no-batch           Disable batched inference (slower but may be more accurate)
#   -h, --help           Show this help message
#
# Examples:
#   transcribe recording.mp3                    # Basic transcription
#   transcribe video.mp4 -f srt                 # Generate SRT subtitles
#   transcribe podcast.wav -l de -o german.txt  # German transcription to file
#   transcribe meeting.m4a --model medium       # Use smaller/faster model

set -e

# Default configuration
DEFAULT_MODEL="medium"
DEFAULT_FORMAT="txt"
COMPUTE_TYPE="int8"
BATCHED="True"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

error() {
    echo -e "${RED}Error:${NC} $1" >&2
    exit 1
}

warn() {
    echo -e "${YELLOW}Warning:${NC} $1" >&2
}

show_help() {
    head -25 "$0" | grep "^#" | sed 's/^# \?//'
    exit 0
}

# Check if whisper-ctranslate2 is installed
if ! command -v whisper-ctranslate2 &> /dev/null; then
    error "whisper-ctranslate2 not found. Install it with: uv tool install whisper-ctranslate2"
fi

# Parse arguments
INPUT_FILE=""
MODEL="$DEFAULT_MODEL"
LANGUAGE=""
OUTPUT_FORMAT="$DEFAULT_FORMAT"
OUTPUT_FILE=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -m|--model)
            MODEL="$2"
            shift 2
            ;;
        -l|--language)
            LANGUAGE="$2"
            shift 2
            ;;
        -f|--format)
            OUTPUT_FORMAT="$2"
            shift 2
            ;;
        -o|--output)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        --no-batch)
            BATCHED="False"
            shift
            ;;
        -h|--help)
            show_help
            ;;
        -*)
            error "Unknown option: $1. Use --help for usage."
            ;;
        *)
            if [ -z "$INPUT_FILE" ]; then
                INPUT_FILE="$1"
            else
                error "Multiple input files not supported. Got: $INPUT_FILE and $1"
            fi
            shift
            ;;
    esac
done

# Validate input
if [ -z "$INPUT_FILE" ]; then
    error "No input file specified. Use --help for usage."
fi

if [ ! -f "$INPUT_FILE" ]; then
    error "Input file not found: $INPUT_FILE"
fi

# Map format to whisper-ctranslate2 output option
case "$OUTPUT_FORMAT" in
    txt)
        OUTPUT_OPT="--output_format txt"
        ;;
    srt)
        OUTPUT_OPT="--output_format srt"
        ;;
    vtt)
        OUTPUT_OPT="--output_format vtt"
        ;;
    json)
        OUTPUT_OPT="--output_format json"
        ;;
    tsv)
        OUTPUT_OPT="--output_format tsv"
        ;;
    *)
        error "Unknown output format: $OUTPUT_FORMAT. Use txt, srt, vtt, json, or tsv."
        ;;
esac

# Build command arguments
ARGS=()
ARGS+=("$INPUT_FILE")
ARGS+=(--model "$MODEL")
ARGS+=(--compute_type "$COMPUTE_TYPE")
ARGS+=(--batched "$BATCHED")

# Add language if specified
if [ -n "$LANGUAGE" ]; then
    ARGS+=(--language "$LANGUAGE")
fi

# Add output directory if output file specified
if [ -n "$OUTPUT_FILE" ]; then
    OUTPUT_DIR=$(dirname "$OUTPUT_FILE")
    ARGS+=(--output_dir "$OUTPUT_DIR")
fi

# Run transcription
whisper-ctranslate2 "${ARGS[@]}" $OUTPUT_OPT

# If output file was specified with different name, rename the output
if [ -n "$OUTPUT_FILE" ]; then
    INPUT_BASENAME=$(basename "$INPUT_FILE" | sed 's/\.[^.]*$//')
    GENERATED_FILE="$(dirname "$OUTPUT_FILE")/${INPUT_BASENAME}.${OUTPUT_FORMAT}"
    if [ -f "$GENERATED_FILE" ] && [ "$GENERATED_FILE" != "$OUTPUT_FILE" ]; then
        mv "$GENERATED_FILE" "$OUTPUT_FILE"
    fi
fi
