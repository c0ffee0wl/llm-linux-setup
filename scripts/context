#!/usr/bin/env python3
"""
Context - Extract terminal history from asciinema session recordings

Extracts prompt blocks (prompt + command + output) from your terminal session.
Each block contains everything from one prompt to the next, preserving the exact
terminal formatting including multi-line commands.

CLI Usage:
    context          # Show last prompt block (default)
    context 5        # Show last 5 prompt blocks
    context all      # Show entire session
    context -a       # Show entire session
    context -e       # Output SESSION_LOG_FILE environment variable

Library Usage:
    from context import get_command_blocks, get_context

    blocks = get_command_blocks(n_commands=3)  # Returns list of prompt blocks
    context_str = get_context(n_commands=3)    # Returns formatted context string
"""

import os
import sys
import subprocess
import tempfile
import re
from typing import List, Optional

# Import shared prompt detection module
try:
    from llm_tools.prompt_detection import PromptDetector
except ImportError:
    # Fallback for development - import from same directory
    from prompt_detection import PromptDetector
import argparse

# Public API for library usage
__all__ = ['get_command_blocks', 'get_context', 'get_session_log_file']


# Compiled regex for filtering AI-related commands
# Matches commands starting with: @, context, llm, llm-shell, aichat, llm-assistant, or wut
FILTERED_COMMANDS = re.compile(r'^(@|context|llm|llm-shell|aichat|llm-assistant|wut)(\s|$)', re.IGNORECASE)


def find_cast_file():
    """Find the current session's cast file"""
    # First, check environment variable
    if "SESSION_LOG_FILE" in os.environ:
        cast_file = os.environ["SESSION_LOG_FILE"]
        if os.path.exists(cast_file):
            return cast_file

    # Fall back to finding most recent cast file in log directory
    log_dir = os.environ.get("SESSION_LOG_DIR", "/tmp/session_logs/asciinema")
    if not os.path.exists(log_dir):
        return None

    cast_files = [
        os.path.join(log_dir, f)
        for f in os.listdir(log_dir)
        if f.endswith(".cast")
    ]

    if not cast_files:
        return None

    # Return most recently modified file
    return max(cast_files, key=os.path.getmtime)


def convert_cast_to_text(cast_file):
    """Convert .cast file to readable text using asciinema"""
    with tempfile.NamedTemporaryFile(mode='w+', suffix='.txt', delete=False) as tmp:
        tmp_path = tmp.name

    try:
        subprocess.run(
            ["asciinema", "convert", cast_file, tmp_path, "--overwrite"],
            check=True,
            capture_output=True
        )

        with open(tmp_path, 'r', encoding='utf-8', errors='replace') as f:
            content = f.read()

        return content
    finally:
        if os.path.exists(tmp_path):
            os.unlink(tmp_path)


def detect_prompts(text_or_lines):
    """
    Detect command prompts in the text.
    Returns list of (line_number, line_content) tuples for lines that are prompts.

    This is a wrapper around PromptDetector.find_all_prompts() for backwards compatibility.
    """
    return PromptDetector.find_all_prompts(text_or_lines)


def should_exclude_block(block):
    """
    Check if a prompt block should be excluded from output.

    Excludes blocks where the command starts with:
    - @ (llm-shell queries)
    - context (with space or end of string)
    - llm (with space)
    - llm-shell (with space or end of string)
    - aichat (with space or end of string)
    - llm-assistant (with space or end of string)
    - wut (with space or end of string)

    Args:
        block: Text block containing prompt + command + output

    Returns:
        True if block should be excluded, False otherwise
    """
    if not block:
        return False

    # Split into non-empty lines
    lines = [line for line in block.split('\n') if line.strip()]

    if not lines:
        return False

    # Strip Unicode prompt markers and tag metadata for pattern matching
    # (consistent with PromptDetector.is_prompt_line and find_all_prompts)
    lines = [PromptDetector.strip_tag_metadata(line)
                  .replace(PromptDetector.PROMPT_START_MARKER, '')
                  .replace(PromptDetector.INPUT_START_MARKER, '')
             for line in lines]

    # Check if this is a Kali-style two-line prompt (use shared pattern)
    command_line_idx = 0

    if len(lines) >= 2 and PromptDetector.KALI_HEADER.search(lines[0]):
        # Skip the decorative header, use second line
        command_line_idx = 1

    if command_line_idx >= len(lines):
        return False

    command_line = lines[command_line_idx]

    # Extract the command after the prompt character
    # Prompt patterns: $ # % ❯ → ➜ for Unix, > for PowerShell
    prompt_chars = r'[$#%❯→➜]'
    match = re.search(f'{prompt_chars}\\s+(.+)', command_line)

    # Check for PowerShell prompts: PS path> command or [user@host]: PS path> command
    if not match:
        ps_match = re.search(r'(?:^\[[^\]]+\]:\s*)?PS[^>]*>\s+(.+)', command_line)
        if ps_match:
            match = ps_match

    if not match:
        # No command found (just a prompt), don't exclude
        return False

    # Get the command and strip leading/trailing whitespace
    command = match.group(1).strip()

    # Check if command matches filtered patterns (case-insensitive)
    return bool(FILTERED_COMMANDS.match(command))


def extract_prompt_blocks(text, count=1):
    """
    Extract prompt blocks (prompt + command + output) from the converted text.

    Args:
        text: Converted asciinema text
        count: Number of recent prompt blocks to extract (None for all)

    Returns:
        List of text blocks, each containing everything from one prompt to the next
    """
    lines = text.split('\n')
    # Filter out lines from previous context command outputs
    lines = [line for line in lines if not line.lstrip().startswith('#c#')]
    # Pass lines directly (no need to rejoin into text)
    prompt_lines = detect_prompts(lines)

    if not prompt_lines:
        return []

    blocks = []

    # Process each prompt line - extract everything from this prompt to the next
    for i, (line_num, prompt_line) in enumerate(prompt_lines):
        # Get all lines from this prompt to the next prompt (or end of text)
        start_line = line_num
        if i + 1 < len(prompt_lines):
            end_line = prompt_lines[i + 1][0]
        else:
            end_line = len(lines)

        block_lines = lines[start_line:end_line]
        block = '\n'.join(block_lines).rstrip()

        # Only append if this block should not be excluded (filter AI commands)
        if not should_exclude_block(block):
            blocks.append(block)

    # Exclude the last block if it's just an empty current prompt
    # or if it's a self-referential context command with no output yet
    if blocks:
        last_block = blocks[-1]
        last_block_lines = [line for line in last_block.split('\n') if line.strip()]

        if not last_block_lines:
            # Completely empty block
            blocks = blocks[:-1]
        elif PromptDetector.detect_prompt_at_end(last_block):
            # Empty prompt (ready for input) - uses hybrid detection:
            # 1. Unicode markers (100% reliable for VTE terminals)
            # 2. Regex fallback (SSH sessions, non-VTE terminals)
            blocks = blocks[:-1]
        else:
            # Check for context command with no output (specific to this tool)
            # Strip markers before pattern matching (markers break \s+ between prompt and command)
            stripped_lines = [
                PromptDetector.strip_tag_metadata(line)
                    .replace(PromptDetector.PROMPT_START_MARKER, '')
                    .replace(PromptDetector.INPUT_START_MARKER, '')
                for line in last_block_lines
            ]

            is_context_command = False
            if len(stripped_lines) == 1:
                if re.search(r'[$#%❯→➜]\s+context(\s|$)', stripped_lines[0]):
                    is_context_command = True
                elif re.search(r'(?:^\[[^\]]+\]:\s*)?PS[^>]*>\s+context(\s|$)', stripped_lines[0]):
                    is_context_command = True
            elif len(stripped_lines) == 2:
                # Kali two-line prompt with context command
                if (PromptDetector.KALI_HEADER.search(stripped_lines[0]) and
                    re.search(r'[$#%❯→➜]\s+context(\s|$)', stripped_lines[1])):
                    is_context_command = True

            if is_context_command:
                blocks = blocks[:-1]

    # Return requested number of blocks
    if count is None:
        return blocks
    else:
        return blocks[-count:]


def format_output(blocks):
    """Format prompt blocks for display"""
    if not blocks:
        return "#c# No prompts found in session recording."

    result = []
    for block in blocks:
        # Prefix each line of the block
        for line in block.split('\n'):
            result.append(f"#c# {line}")
        result.append("#c# ")  # Blank line separator between blocks

    return '\n'.join(result)


# =============================================================================
# Public API - Library Functions
# =============================================================================

def get_session_log_file() -> Optional[str]:
    """
    Get the path to the current session's asciinema recording.

    Returns:
        Path to the .cast file, or None if not found.

    Example:
        >>> from context import get_session_log_file
        >>> log_file = get_session_log_file()
        >>> if log_file:
        ...     print(f"Recording: {log_file}")
    """
    return find_cast_file()


def get_command_blocks(n_commands: int = 3) -> List[str]:
    """
    Extract the last N command blocks from the current asciinema recording.

    Each block contains a prompt line, the command, and its output
    (everything from one prompt to the next).

    Args:
        n_commands: Number of recent prompt blocks to extract.
                   Use None for all blocks.

    Returns:
        List of prompt block strings. Empty list if no session found
        or no prompts detected.

    Raises:
        FileNotFoundError: If asciinema command is not installed.
        subprocess.CalledProcessError: If cast file conversion fails.

    Example:
        >>> from context import get_command_blocks
        >>> blocks = get_command_blocks(3)
        >>> for block in blocks:
        ...     print(block)
        ...     print("---")
    """
    cast_file = find_cast_file()
    if not cast_file:
        return []

    text = convert_cast_to_text(cast_file)
    return extract_prompt_blocks(text, n_commands)


def get_context(n_commands: int = 3, raw: bool = False) -> str:
    """
    Get formatted context string from the current asciinema recording.

    This is the main entry point for library usage. Returns the last N
    command blocks formatted for injection into AI prompts.

    Args:
        n_commands: Number of recent prompt blocks to include.
                   Use None for all blocks.
        raw: If True, return blocks joined without #c# prefix formatting.
             If False (default), return with #c# prefix on each line.

    Returns:
        Formatted context string. Returns empty string if no session found.

    Example:
        >>> from context import get_context
        >>> context_str = get_context(3)
        >>> print(context_str)

        # For raw output (no #c# prefix):
        >>> raw_context = get_context(3, raw=True)
    """
    blocks = get_command_blocks(n_commands)

    if not blocks:
        return "" if raw else "#c# No prompts found in session recording."

    if raw:
        return '\n\n'.join(blocks)
    else:
        return format_output(blocks)


def main():
    # Parse arguments
    parser = argparse.ArgumentParser(description='Extract prompt blocks from terminal session')
    parser.add_argument('count', nargs='?', default=1,
                       help='Number of recent prompt blocks to show or "all" for entire history (default: 1)')
    parser.add_argument('-e', '--environment', action='store_true',
                       help='Output SESSION_LOG_FILE environment variable')
    parser.add_argument('-a', '--all', action='store_true',
                       help='Show entire history')

    args = parser.parse_args()

    # Find cast file
    cast_file = find_cast_file()

    # Handle -e/--environment flag
    if args.environment:
        if cast_file:
            export_cmd = f"export SESSION_LOG_FILE='{cast_file}'"
            print(export_cmd)

            # Try to copy to clipboard using xsel (both PRIMARY and CLIPBOARD)
            try:
                # Copy to PRIMARY selection (middle-click paste)
                subprocess.run(
                    ['xsel', '--primary', '--input'],
                    input=export_cmd.encode(),
                    check=True,
                    capture_output=True
                )
                # Copy to CLIPBOARD selection (Ctrl+V paste)
                subprocess.run(
                    ['xsel', '--clipboard', '--input'],
                    input=export_cmd.encode(),
                    check=True,
                    capture_output=True
                )
                print("# Command copied to clipboard", file=sys.stderr)
            except (subprocess.CalledProcessError, FileNotFoundError):
                # xsel not available or failed - silently continue
                pass
        else:
            print("# No asciinema session recording found", file=sys.stderr)
            sys.exit(1)
        return

    # Determine if we want all history
    show_all = args.all or args.count == 'all'

    if show_all:
        count = None  # Signal to show all
    else:
        # Validate count is a number
        try:
            count = int(args.count)
            # Convert negative to positive with a note
            if count < 0:
                count = abs(count)
                print(f"#c# context usage note: Using {count} (converted from negative value)", file=sys.stderr)
            # Still validate that it's not zero
            if count < 1:
                raise ValueError()
        except (ValueError, TypeError):
            print("Error: Please provide a positive number or 'all'", file=sys.stderr)
            parser.print_help(sys.stderr)
            sys.exit(1)

    if not cast_file:
        print("Error: No asciinema session recording found.", file=sys.stderr)
        print("Make sure you're in a shell with asciinema recording enabled.", file=sys.stderr)
        sys.exit(1)

    # Convert to text
    try:
        text = convert_cast_to_text(cast_file)
    except subprocess.CalledProcessError as e:
        print(f"Error: Failed to convert cast file: {e}", file=sys.stderr)
        sys.exit(1)
    except FileNotFoundError:
        print("Error: asciinema command not found. Is it installed?", file=sys.stderr)
        sys.exit(1)

    # Extract prompt blocks
    blocks = extract_prompt_blocks(text, count)

    # Display results
    print(format_output(blocks))


if __name__ == "__main__":
    main()
