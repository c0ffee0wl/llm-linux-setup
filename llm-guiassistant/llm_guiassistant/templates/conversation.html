<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- JavaScript assets loaded from ~/.local/share/llm-guiassistant/js/ -->
    <!-- Note: $HOME is expanded at runtime by popup.py when loading template -->
    <script src="file://$HOME/.local/share/llm-guiassistant/js/marked.min.js"></script>
    <script src="file://$HOME/.local/share/llm-guiassistant/js/highlight.min.js"></script>
    <style>
        /* Light theme (default) */
        :root {
            --bg-color: #ffffff;
            --text-color: #1a1a1a;
            --code-bg: #f5f5f5;
            --border-color: #e0e0e0;
            --user-bg: #e3f2fd;
            --assistant-bg: #fafafa;
            --button-bg: #e8e8e8;
            --button-hover: #d0d0d0;
            --tool-bg: #fff3e0;
            --error-bg: #ffebee;
        }

        /* Dark theme - WebKit2GTK respects system preference */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #1e1e1e;
                --text-color: #e0e0e0;
                --code-bg: #2d2d2d;
                --border-color: #444444;
                --user-bg: #1e3a5f;
                --assistant-bg: #2a2a2a;
                --button-bg: #3d3d3d;
                --button-hover: #4d4d4d;
                --tool-bg: #3e2723;
                --error-bg: #4a1c1c;
            }
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            font-size: 14px;
            line-height: 1.5;
            background: var(--bg-color);
            color: var(--text-color);
            padding: 8px;
        }

        #conversation {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .message {
            padding: 12px;
            border-radius: 8px;
            max-width: 100%;
            word-wrap: break-word;
        }

        .user {
            background: var(--user-bg);
            margin-left: 20%;
            border-radius: 8px;
        }

        /* ChatGPT/Gemini-style: No background on assistant messages */
        .assistant {
            background: transparent;
            margin-right: 0;
            padding: 12px 0;
        }

        .tool-status {
            background: var(--tool-bg);
            font-size: 0.9em;
            padding: 8px 12px;
            border-radius: 4px;
            font-style: italic;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tool-status.running::before {
            content: '';
            width: 12px;
            height: 12px;
            border: 2px solid var(--border-color);
            border-top-color: #1976d2;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @media (prefers-color-scheme: dark) {
            .tool-status.running::before {
                border-top-color: #64b5f6;
            }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .tool-status.completed {
            opacity: 0.7;
        }

        .tool-status.completed::before {
            content: 'âœ“';
            color: #4caf50;
            font-style: normal;
        }

        .error {
            background: var(--error-bg);
            border-left: 3px solid #f44336;
        }

        /* Empty state styling */
        .empty-state {
            text-align: center;
            color: var(--text-color);
            opacity: 0.6;
            padding: 48px 24px;
        }

        .empty-state h2 {
            font-size: 1.2em;
            margin-bottom: 8px;
            font-weight: normal;
        }

        .empty-state p {
            font-size: 0.9em;
        }

        /* Markdown content styling */
        .message h1, .message h2, .message h3 {
            margin-top: 12px;
            margin-bottom: 8px;
        }

        .message p {
            margin-bottom: 8px;
        }

        .message ul, .message ol {
            margin-left: 20px;
            margin-bottom: 8px;
        }

        .message a {
            color: #1976d2;
        }

        @media (prefers-color-scheme: dark) {
            .message a {
                color: #64b5f6;
            }
        }

        /* Code blocks */
        pre {
            background: var(--code-bg);
            padding: 12px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 8px 0;
            position: relative;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        pre code {
            font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-break: break-word;
        }

        code {
            font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
            background: var(--code-bg);
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }

        pre code {
            background: transparent;
            padding: 0;
        }

        /* Syntax highlighting - Light theme (GitHub-inspired) */
        .hljs-keyword { color: #d73a49; }
        .hljs-string { color: #032f62; }
        .hljs-number { color: #005cc5; }
        .hljs-comment { color: #6a737d; font-style: italic; }
        .hljs-function { color: #6f42c1; }
        .hljs-class { color: #22863a; }
        .hljs-variable { color: #e36209; }
        .hljs-built_in { color: #005cc5; }
        .hljs-literal { color: #005cc5; }
        .hljs-type { color: #22863a; }
        .hljs-params { color: #24292e; }
        .hljs-meta { color: #6a737d; }
        .hljs-title { color: #6f42c1; }
        .hljs-attr { color: #005cc5; }
        .hljs-attribute { color: #005cc5; }
        .hljs-selector-tag { color: #22863a; }
        .hljs-selector-class { color: #6f42c1; }
        .hljs-selector-id { color: #005cc5; }
        .hljs-tag { color: #22863a; }
        .hljs-name { color: #22863a; }
        .hljs-doctag { color: #d73a49; }
        .hljs-template-variable { color: #e36209; }
        .hljs-template-tag { color: #6f42c1; }
        .hljs-regexp { color: #032f62; }
        .hljs-link { color: #032f62; text-decoration: underline; }
        .hljs-symbol { color: #005cc5; }
        .hljs-bullet { color: #005cc5; }
        .hljs-subst { color: #24292e; }
        .hljs-property { color: #005cc5; }
        .hljs-section { color: #005cc5; font-weight: bold; }
        .hljs-emphasis { font-style: italic; }
        .hljs-strong { font-weight: bold; }

        /* Syntax highlighting - Dark theme (GitHub Dark-inspired) */
        @media (prefers-color-scheme: dark) {
            .hljs-keyword { color: #ff7b72; }
            .hljs-string { color: #a5d6ff; }
            .hljs-number { color: #79c0ff; }
            .hljs-comment { color: #8b949e; }
            .hljs-function { color: #d2a8ff; }
            .hljs-class { color: #7ee787; }
            .hljs-variable { color: #ffa657; }
            .hljs-built_in { color: #79c0ff; }
            .hljs-literal { color: #79c0ff; }
            .hljs-type { color: #7ee787; }
            .hljs-params { color: #c9d1d9; }
            .hljs-meta { color: #8b949e; }
            .hljs-title { color: #d2a8ff; }
            .hljs-attr { color: #79c0ff; }
            .hljs-attribute { color: #79c0ff; }
            .hljs-selector-tag { color: #7ee787; }
            .hljs-selector-class { color: #d2a8ff; }
            .hljs-selector-id { color: #79c0ff; }
            .hljs-tag { color: #7ee787; }
            .hljs-name { color: #7ee787; }
            .hljs-doctag { color: #ff7b72; }
            .hljs-template-variable { color: #ffa657; }
            .hljs-template-tag { color: #d2a8ff; }
            .hljs-regexp { color: #a5d6ff; }
            .hljs-link { color: #a5d6ff; }
            .hljs-symbol { color: #79c0ff; }
            .hljs-bullet { color: #79c0ff; }
            .hljs-subst { color: #c9d1d9; }
            .hljs-property { color: #79c0ff; }
            .hljs-section { color: #79c0ff; font-weight: bold; }
        }

        /* Copy button on code blocks - ChatGPT style */
        .code-wrapper {
            position: relative;
        }

        .copy-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            background: var(--button-bg);
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            color: var(--text-color);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .code-wrapper:hover .copy-btn {
            opacity: 1;
        }

        .copy-btn:hover {
            background: var(--button-hover);
        }

        .copy-btn svg {
            width: 12px;
            height: 12px;
        }

        .action-btn {
            background: var(--button-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 10px;
            font-size: 12px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .action-btn:hover {
            background: var(--button-hover);
        }

        /* Images */
        .message img {
            max-width: 100%;
            border-radius: 4px;
            margin: 8px 0;
        }

        /* Tables */
        .message table {
            border-collapse: collapse;
            margin: 8px 0;
            width: 100%;
        }

        .message th, .message td {
            border: 1px solid var(--border-color);
            padding: 8px;
            text-align: left;
        }

        .message th {
            background: var(--code-bg);
        }

        /* Message action icons - always visible at bottom-left */
        .message-actions {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }

        .message-action-btn {
            background: transparent;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: var(--text-color);
            opacity: 0.4;
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            transition: opacity 0.2s;
        }

        .message-action-btn:hover {
            opacity: 1;
        }

        /* Show Edit only on last user message */
        .message.user .action-edit { display: none; }
        .message.user.last-user .action-edit { display: flex; }

        /* Show Regenerate only on last assistant message */
        .message.assistant .action-regenerate { display: none; }
        .message.assistant.last-assistant .action-regenerate { display: flex; }

        /* Inline Editor */
        .inline-editor { margin-top: 8px; }

        .inline-editor-textarea {
            width: 100%;
            min-height: 60px;
            max-height: 300px;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-color);
            color: var(--text-color);
            font-family: inherit;
            font-size: 14px;
            line-height: 1.5;
            resize: none;
        }

        .inline-editor-textarea:focus {
            outline: none;
            border-color: #1976d2;
        }

        @media (prefers-color-scheme: dark) {
            .inline-editor-textarea:focus {
                border-color: #64b5f6;
            }
        }

        .inline-editor-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 8px;
        }

        .inline-editor-cancel,
        .inline-editor-save {
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        .inline-editor-cancel {
            background: var(--button-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }

        .inline-editor-save {
            background: #1976d2;
            border: none;
            color: white;
        }

        @media (prefers-color-scheme: dark) {
            .inline-editor-save {
                background: #2196f3;
            }
        }

        /* Toast notification */
        #toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: var(--code-bg);
            color: var(--text-color);
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 13px;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            z-index: 1000;
            border: 1px solid var(--border-color);
        }

        #toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    </style>
</head>
<body>
    <div id="conversation">
        <!-- Empty state shown when no messages -->
        <div class="empty-state" id="empty-state">
            <h2>How can I help you today?</h2>
            <p>Type a question below and press Enter to send.</p>
        </div>
    </div>

    <script>
        // Check if required libraries loaded
        if (typeof marked === 'undefined' || typeof hljs === 'undefined') {
            document.body.innerHTML = '<div style="padding: 20px; color: #c00;">' +
                '<h3>JavaScript assets failed to load</h3>' +
                '<p>Missing: ' +
                (typeof marked === 'undefined' ? 'marked.js ' : '') +
                (typeof hljs === 'undefined' ? 'highlight.js' : '') +
                '</p>' +
                '<p>Expected location: ~/.local/share/llm-guiassistant/js/</p>' +
                '<p>Run: <code>./install-llm-tools.sh</code> to download assets.</p>' +
                '</div>';
            throw new Error('Required JavaScript libraries not loaded');
        }

        // Configure marked for safe rendering
        marked.setOptions({
            breaks: true,
            gfm: true
        });

        // Security: Strip raw HTML to prevent XSS attacks from LLM responses
        const renderer = new marked.Renderer();
        renderer.html = function(token) {
            return '';
        };
        marked.use({ renderer });

        // Track current streaming message
        let currentMessageId = null;

        // Message store for tracking conversation history
        const messageStore = {
            messages: [],

            add(role, content, element) {
                const id = `msg-${Date.now()}-${this.messages.length}`;
                element.dataset.messageId = id;
                element.dataset.messageIndex = this.messages.length;
                this.messages.push({ id, role, content, element });
                return id;
            },

            getLastByRole(role) {
                for (let i = this.messages.length - 1; i >= 0; i--) {
                    if (this.messages[i].role === role) return this.messages[i];
                }
                return null;
            },

            truncateAfter(id) {
                const idx = this.messages.findIndex(m => m.id === id);
                if (idx === -1) return;
                for (let i = idx + 1; i < this.messages.length; i++) {
                    this.messages[i].element?.remove();
                }
                this.messages = this.messages.slice(0, idx + 1);
            },

            removeMessage(id) {
                const idx = this.messages.findIndex(m => m.id === id);
                if (idx === -1) return null;
                const msg = this.messages[idx];
                msg.element?.remove();
                this.messages.splice(idx, 1);
                this.messages.forEach((m, i) => {
                    m.element.dataset.messageIndex = i;
                });
                return msg;
            },

            getMessagesUpTo(id) {
                const idx = this.messages.findIndex(m => m.id === id);
                return idx === -1 ? [] : this.messages.slice(0, idx + 1);
            },

            clear() {
                this.messages = [];
            }
        };

        // SVG Icons
        const ICONS = {
            copy: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg>',
            copyPlain: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/><text x="15.5" y="18" font-size="8" fill="currentColor" stroke="none" text-anchor="middle">T</text></svg>',
            edit: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>',
            regenerate: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 11-2.12-9.36L23 10"/></svg>',
            branch: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="6" y1="3" x2="6" y2="15"/><circle cx="18" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><path d="M18 9a9 9 0 01-9 9"/></svg>'
        };

        // Add readline-style keyboard shortcuts to a textarea
        // Supports: Ctrl+W (delete word), Ctrl+U (clear line), Ctrl+A (start of line), Ctrl+E (end of line)
        // Pass optional onResize callback for auto-resizing textareas
        function addReadlineShortcuts(textarea, onResize) {
            textarea.addEventListener('keydown', (e) => {
                if (!e.ctrlKey) return;

                if (e.key === 'w' || e.key === 'Backspace') {
                    // Ctrl+W / Ctrl+Backspace: delete previous word
                    e.preventDefault();
                    const pos = textarea.selectionStart;
                    if (pos > 0) {
                        const text = textarea.value;
                        let start = pos;
                        // Skip whitespace backwards
                        while (start > 0 && /\s/.test(text[start - 1])) start--;
                        // Skip word backwards
                        while (start > 0 && !/\s/.test(text[start - 1])) start--;
                        textarea.value = text.slice(0, start) + text.slice(pos);
                        textarea.setSelectionRange(start, start);
                        if (onResize) onResize();
                    }
                }
                else if (e.key === 'u') {
                    // Ctrl+U: clear line before cursor
                    e.preventDefault();
                    const pos = textarea.selectionStart;
                    const text = textarea.value;
                    let lineStart = text.lastIndexOf('\n', pos - 1) + 1;
                    textarea.value = text.slice(0, lineStart) + text.slice(pos);
                    textarea.setSelectionRange(lineStart, lineStart);
                    if (onResize) onResize();
                }
                else if (e.key === 'a') {
                    // Ctrl+A: go to beginning of line (not select all)
                    e.preventDefault();
                    const pos = textarea.selectionStart;
                    const text = textarea.value;
                    let lineStart = text.lastIndexOf('\n', pos - 1) + 1;
                    textarea.setSelectionRange(lineStart, lineStart);
                }
                else if (e.key === 'e') {
                    // Ctrl+E: go to end of line
                    e.preventDefault();
                    const pos = textarea.selectionStart;
                    const text = textarea.value;
                    let lineEnd = text.indexOf('\n', pos);
                    if (lineEnd === -1) lineEnd = text.length;
                    textarea.setSelectionRange(lineEnd, lineEnd);
                }
            });
        }

        // Strip markdown formatting from text (preserves code block content)
        // JS port of llm_tools_core.strip_markdown for use in WebKit context
        function stripMarkdown(text) {
            // Extract and preserve code blocks
            const codeBlocks = [];
            text = text.replace(/```\w*\n([\s\S]*?)```/g, (match, code) => {
                codeBlocks.push(code.trim());
                return `\x00CODE${codeBlocks.length - 1}\x00`;
            });

            // Strip inline markdown formatting
            const patterns = [
                [/`([^`]+)`/g, '$1'],                      // Inline code
                [/\*\*([^*]+)\*\*/g, '$1'],                // Bold **text**
                [/__([^_]+)__/g, '$1'],                    // Bold __text__
                [/\*([^*]+)\*/g, '$1'],                    // Italic *text*
                [/_([^_]+)_/g, '$1'],                      // Italic _text_
                [/~~([^~]+)~~/g, '$1'],                    // Strikethrough
                [/^#{1,6}\s*/gm, ''],                      // Headers
                [/^>\s*/gm, ''],                           // Blockquotes
                [/^[-*+]\s+/gm, ''],                       // Unordered lists
                [/^\d+\.\s+/gm, ''],                       // Ordered lists
                [/!\[([^\]]*)\]\([^)]+\)/g, '$1'],         // Images
                [/\[([^\]]+)\]\([^)]+\)/g, '$1'],          // Links
                [/^[-*_]{3,}\s*$/gm, ''],                  // Horizontal rules
            ];

            for (const [pattern, replacement] of patterns) {
                text = text.replace(pattern, replacement);
            }

            // Restore code blocks
            for (let i = 0; i < codeBlocks.length; i++) {
                text = text.replace(`\x00CODE${i}\x00`, codeBlocks[i]);
            }

            return text;
        }

        // Helper: escape HTML for safe textarea content
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Toast notification
        function showToast(message) {
            let toast = document.getElementById('toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'toast';
                document.body.appendChild(toast);
            }
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        // Apply code block enhancements (ChatGPT-style copy button + syntax highlighting)
        function applyCodeBlockEnhancements(container) {
            container.querySelectorAll('pre').forEach(pre => {
                if (!pre.parentElement.classList.contains('code-wrapper')) {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'code-wrapper';
                    pre.parentNode.insertBefore(wrapper, pre);
                    wrapper.appendChild(pre);

                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'copy-btn';
                    copyBtn.innerHTML = ICONS.copy + '<span>Copy code</span>';
                    copyBtn.onclick = function() {
                        const code = pre.querySelector('code') || pre;
                        navigator.clipboard.writeText(code.textContent);
                        copyBtn.innerHTML = ICONS.copy + '<span>Copied!</span>';
                        setTimeout(() => {
                            copyBtn.innerHTML = ICONS.copy + '<span>Copy code</span>';
                        }, 1500);
                    };
                    wrapper.appendChild(copyBtn);
                }
            });

            container.querySelectorAll('pre code').forEach(block => {
                hljs.highlightElement(block);
            });
        }

        // Update last-user and last-assistant classes for conditional icon visibility
        function updateLastMessageIndicators() {
            document.querySelectorAll('.message.last-user, .message.last-assistant')
                .forEach(el => el.classList.remove('last-user', 'last-assistant'));

            const lastUser = messageStore.getLastByRole('user');
            const lastAssistant = messageStore.getLastByRole('assistant');

            if (lastUser?.element) lastUser.element.classList.add('last-user');
            if (lastAssistant?.element) lastAssistant.element.classList.add('last-assistant');
        }

        // Create action icon button
        function createIconButton(iconName, tooltip, onClick) {
            const btn = document.createElement('button');
            btn.className = 'message-action-btn';
            btn.innerHTML = ICONS[iconName];
            btn.title = tooltip;
            btn.onclick = (e) => { e.stopPropagation(); onClick(); };
            return btn;
        }

        // Create action icons for a message
        function createActionIcons(role, messageId) {
            const container = document.createElement('div');
            container.className = 'message-actions';

            // Copy markdown (always)
            container.appendChild(createIconButton('copy', 'Copy markdown', () => {
                const msg = messageStore.messages.find(m => m.id === messageId);
                if (msg) {
                    navigator.clipboard.writeText(msg.content);
                    showToast('Copied to clipboard');
                }
            }));

            // Copy plain text (strip markdown) - for assistant only
            if (role === 'assistant') {
                container.appendChild(createIconButton('copyPlain', 'Copy plain text', () => {
                    const msg = messageStore.messages.find(m => m.id === messageId);
                    if (msg) {
                        navigator.clipboard.writeText(stripMarkdown(msg.content));
                        showToast('Copied plain text');
                    }
                }));
            }

            if (role === 'user') {
                // Edit (last user only - visibility controlled by CSS)
                const editBtn = createIconButton('edit', 'Edit', () => showInlineEditor(messageId));
                editBtn.classList.add('action-edit');
                container.appendChild(editBtn);
            } else if (role === 'assistant') {
                // Regenerate (last assistant only)
                const regenBtn = createIconButton('regenerate', 'Regenerate', () => regenerateResponse(messageId));
                regenBtn.classList.add('action-regenerate');
                container.appendChild(regenBtn);

                // Branch (always on assistant)
                container.appendChild(createIconButton('branch', 'Branch', () => branchConversation(messageId)));
            }

            return container;
        }

        // Inline editor state
        let activeEditor = null;

        function showInlineEditor(messageId) {
            if (activeEditor) cancelInlineEditor();

            const msg = messageStore.messages.find(m => m.id === messageId);
            if (!msg || msg.role !== 'user') return;

            const container = msg.element;
            const contentDiv = container.querySelector('.message-content');

            contentDiv.style.display = 'none';

            const editor = document.createElement('div');
            editor.className = 'inline-editor';
            editor.innerHTML = `
                <textarea class="inline-editor-textarea">${escapeHtml(msg.content)}</textarea>
                <div class="inline-editor-actions">
                    <button class="inline-editor-cancel">Cancel</button>
                    <button class="inline-editor-save">Save & Regenerate</button>
                </div>
            `;

            container.appendChild(editor);

            const textarea = editor.querySelector('textarea');
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);

            const autoResize = () => {
                textarea.style.height = 'auto';
                textarea.style.height = textarea.scrollHeight + 'px';
            };
            autoResize();
            textarea.addEventListener('input', autoResize);

            editor.querySelector('.inline-editor-cancel').onclick = cancelInlineEditor;
            editor.querySelector('.inline-editor-save').onclick = () => {
                const newContent = textarea.value.trim();
                if (newContent) submitEditedMessage(messageId, newContent);
            };

            // Escape and Ctrl+Enter handlers
            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') cancelInlineEditor();
                else if (e.key === 'Enter' && e.ctrlKey) {
                    const newContent = textarea.value.trim();
                    if (newContent) submitEditedMessage(messageId, newContent);
                }
            });

            // Add readline shortcuts (Ctrl+W, Ctrl+U, Ctrl+A, Ctrl+E)
            addReadlineShortcuts(textarea, autoResize);

            activeEditor = { messageId, container, contentDiv, editor };
        }

        function cancelInlineEditor() {
            if (!activeEditor) return;
            activeEditor.contentDiv.style.display = '';
            activeEditor.editor.remove();
            activeEditor = null;
        }

        function submitEditedMessage(messageId, newContent) {
            cancelInlineEditor();

            const msg = messageStore.messages.find(m => m.id === messageId);
            if (!msg) return;

            msg.content = newContent;
            const contentDiv = msg.element.querySelector('.message-content');
            contentDiv.innerHTML = marked.parse(newContent);
            applyCodeBlockEnhancements(contentDiv);

            messageStore.truncateAfter(messageId);
            updateLastMessageIndicators();

            // Count completed turns (user+assistant pairs) before this message
            // Each turn = one Response object in daemon's conversation.responses
            const msgIndex = messageStore.messages.findIndex(m => m.id === messageId);
            let turnCount = 0;
            for (let i = 0; i < msgIndex; i++) {
                if (messageStore.messages[i].role === 'assistant') {
                    turnCount++;
                }
            }

            window.webkit.messageHandlers.editAndRegenerate.postMessage({
                keepTurns: turnCount,
                newContent: newContent
            });
        }

        function regenerateResponse(messageId) {
            const msg = messageStore.messages.find(m => m.id === messageId);
            if (!msg || msg.role !== 'assistant') return;

            const msgIndex = messageStore.messages.findIndex(m => m.id === messageId);
            let userMsg = null;
            for (let i = msgIndex - 1; i >= 0; i--) {
                if (messageStore.messages[i].role === 'user') {
                    userMsg = messageStore.messages[i];
                    break;
                }
            }
            if (!userMsg) return;

            messageStore.removeMessage(messageId);
            updateLastMessageIndicators();

            window.webkit.messageHandlers.regenerate.postMessage({
                userContent: userMsg.content
            });
        }

        function branchConversation(messageId) {
            const messages = messageStore.getMessagesUpTo(messageId);
            if (messages.length === 0) return;

            const conversationData = messages.map(m => ({
                role: m.role,
                content: m.content
            }));

            window.webkit.messageHandlers.branchConversation.postMessage({
                conversation: conversationData
            });
        }

        function appendMessage(role, content, streamingId) {
            const emptyState = document.getElementById('empty-state');
            if (emptyState) {
                emptyState.remove();
            }

            const conversation = document.getElementById('conversation');
            let container;

            // For streaming: update existing container if same ID
            if (streamingId && streamingId === currentMessageId) {
                container = document.getElementById('current-message');
                if (container) {
                    const contentDiv = container.querySelector('.message-content');
                    contentDiv.innerHTML = marked.parse(content);
                    applyCodeBlockEnhancements(contentDiv);
                    // Update stored content
                    const msgId = container.dataset.messageId;
                    const msg = messageStore.messages.find(m => m.id === msgId);
                    if (msg) msg.content = content;
                    window.scrollTo(0, document.body.scrollHeight);
                    return;
                }
            }

            // Create new message container
            container = document.createElement('div');
            container.className = 'message ' + role;

            // Content wrapper
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.innerHTML = marked.parse(content);
            container.appendChild(contentDiv);

            // Register in message store
            const msgId = messageStore.add(role, content, container);

            // Add action icons
            const actions = createActionIcons(role, msgId);
            container.appendChild(actions);

            // Streaming ID tracking
            if (role === 'assistant' && streamingId) {
                container.id = 'current-message';
                currentMessageId = streamingId;
            }

            conversation.appendChild(container);
            applyCodeBlockEnhancements(contentDiv);
            updateLastMessageIndicators();
            window.scrollTo(0, document.body.scrollHeight);
        }

        function finalizeMessage() {
            const current = document.getElementById('current-message');
            if (current) {
                current.removeAttribute('id');
            }
            currentMessageId = null;
            updateLastMessageIndicators();
        }

        function addToolStatus(message) {
            const conversation = document.getElementById('conversation');
            const statusDiv = document.createElement('div');
            statusDiv.className = 'message tool-status running';
            statusDiv.id = 'current-tool-status';
            statusDiv.textContent = message;
            conversation.appendChild(statusDiv);
            window.scrollTo(0, document.body.scrollHeight);
        }

        function completeToolStatus() {
            const current = document.getElementById('current-tool-status');
            if (current) {
                current.classList.remove('running');
                current.classList.add('completed');
                current.removeAttribute('id');
            }
        }

        function addError(message) {
            const conversation = document.getElementById('conversation');
            const errorDiv = document.createElement('div');
            errorDiv.className = 'message error';
            errorDiv.textContent = message;
            conversation.appendChild(errorDiv);
            window.scrollTo(0, document.body.scrollHeight);
        }

        function clearConversation() {
            const conversation = document.getElementById('conversation');
            conversation.innerHTML = `
                <div class="empty-state" id="empty-state">
                    <h2>How can I help you today?</h2>
                    <p>Type a question below and press Enter to send.</p>
                </div>
            `;
            currentMessageId = null;
            messageStore.clear();
        }

        // Expose functions to Python via webkit message handler
        // Python calls these via webview.run_javascript()
    </script>
</body>
</html>
