#!/usr/bin/env python3
"""
Context - Extract terminal history from asciinema session recordings

Extracts prompt blocks (prompt + command + output) from your terminal session.
Each block contains everything from one prompt to the next, preserving the exact
terminal formatting including multi-line commands.

Usage:
    context          # Show last prompt block (default)
    context 5        # Show last 5 prompt blocks
    context all      # Show entire session
    context -a       # Show entire session
    context -e       # Output SESSION_LOG_FILE environment variable
Usage:
    context [number|all]
    context -a | --all
    context -e | --environment
Example:
    context 5 (shows last 5 prompt blocks)
    context all (shows entire history)
    context -a (shows entire history)
    context -e (outputs export command for SESSION_LOG_FILE)
"""

import os
import sys
import subprocess
import tempfile
import re

# Import shared prompt detection module
try:
    from llm_tools.prompt_detection import PromptDetector
except ImportError:
    # Fallback for development - import from same directory
    from prompt_detection import PromptDetector
import argparse


# Compiled regex for filtering AI-related commands
# Matches commands starting with: context, llm, aichat, llm-sidechat, or wut
FILTERED_COMMANDS = re.compile(r'^(context|llm|aichat|llm-sidechat|wut)(\s|$)', re.IGNORECASE)


def find_cast_file():
    """Find the current session's cast file"""
    # First, check environment variable
    if "SESSION_LOG_FILE" in os.environ:
        cast_file = os.environ["SESSION_LOG_FILE"]
        if os.path.exists(cast_file):
            return cast_file

    # Fall back to finding most recent cast file in log directory
    log_dir = os.environ.get("SESSION_LOG_DIR", "/tmp/session_logs/asciinema")
    if not os.path.exists(log_dir):
        return None

    cast_files = [
        os.path.join(log_dir, f)
        for f in os.listdir(log_dir)
        if f.endswith(".cast")
    ]

    if not cast_files:
        return None

    # Return most recently modified file
    return max(cast_files, key=os.path.getmtime)


def convert_cast_to_text(cast_file):
    """Convert .cast file to readable text using asciinema"""
    with tempfile.NamedTemporaryFile(mode='w+', suffix='.txt', delete=False) as tmp:
        tmp_path = tmp.name

    try:
        subprocess.run(
            ["asciinema", "convert", cast_file, tmp_path, "--overwrite"],
            check=True,
            capture_output=True
        )

        with open(tmp_path, 'r', encoding='utf-8', errors='replace') as f:
            content = f.read()

        return content
    finally:
        if os.path.exists(tmp_path):
            os.unlink(tmp_path)


def detect_prompts(text_or_lines):
    """
    Detect command prompts in the text.
    Returns list of (line_number, line_content) tuples for lines that are prompts.

    This is a wrapper around PromptDetector.find_all_prompts() for backwards compatibility.
    """
    return PromptDetector.find_all_prompts(text_or_lines)


def should_exclude_block(block):
    """
    Check if a prompt block should be excluded from output.

    Excludes blocks where the command starts with:
    - context (with space or end of string)
    - llm (with space)
    - aichat (with space or end of string)
    - llm-sidechat (with space or end of string)

    Args:
        block: Text block containing prompt + command + output

    Returns:
        True if block should be excluded, False otherwise
    """
    if not block:
        return False

    # Split into non-empty lines
    lines = [line for line in block.split('\n') if line.strip()]

    if not lines:
        return False

    # Check if this is a Kali-style two-line prompt
    kali_header_pattern = r'^[┌╭]──.*[\])]$'
    command_line_idx = 0

    if len(lines) >= 2 and re.search(kali_header_pattern, lines[0]):
        # Skip the decorative header, use second line
        command_line_idx = 1

    if command_line_idx >= len(lines):
        return False

    command_line = lines[command_line_idx]

    # Extract the command after the prompt character
    # Prompt patterns: $ # % ❯ → ➜
    prompt_chars = r'[$#%❯→➜]'
    match = re.search(f'{prompt_chars}\\s+(.+)', command_line)

    if not match:
        # No command found (just a prompt), don't exclude
        return False

    # Get the command and strip leading/trailing whitespace
    command = match.group(1).strip()

    # Check if command matches filtered patterns (case-insensitive)
    return bool(FILTERED_COMMANDS.match(command))


def extract_prompt_blocks(text, count=1):
    """
    Extract prompt blocks (prompt + command + output) from the converted text.

    Args:
        text: Converted asciinema text
        count: Number of recent prompt blocks to extract (None for all)

    Returns:
        List of text blocks, each containing everything from one prompt to the next
    """
    lines = text.split('\n')
    # Filter out lines from previous context command outputs
    lines = [line for line in lines if not line.lstrip().startswith('#c#')]
    # Pass lines directly (no need to rejoin into text)
    prompt_lines = detect_prompts(lines)

    if not prompt_lines:
        return []

    blocks = []

    # Process each prompt line - extract everything from this prompt to the next
    for i, (line_num, prompt_line) in enumerate(prompt_lines):
        # Get all lines from this prompt to the next prompt (or end of text)
        start_line = line_num
        if i + 1 < len(prompt_lines):
            end_line = prompt_lines[i + 1][0]
        else:
            end_line = len(lines)

        block_lines = lines[start_line:end_line]
        block = '\n'.join(block_lines).rstrip()

        # Only append if this block should not be excluded (filter AI commands)
        if not should_exclude_block(block):
            blocks.append(block)

    # Exclude the last block if it's just an empty current prompt
    # or if it's a self-referential context command with no output yet
    if blocks:
        last_block_lines = [line for line in blocks[-1].split('\n') if line.strip()]

        if not last_block_lines:
            # Completely empty block
            blocks = blocks[:-1]
        elif len(last_block_lines) == 1:
            # Single-line prompt: check if it's just a prompt with no command
            if re.search(r'[$#%❯→➜]\s*$', last_block_lines[0]):
                blocks = blocks[:-1]
            # Or check if it's context command with no output
            elif re.search(r'[$#%❯→➜]\s+context(\s|$)', last_block_lines[0]):
                blocks = blocks[:-1]
        elif len(last_block_lines) == 2:
            # Potential two-line prompt (Kali/fancy prompts)
            # Check if first line is header and second is prompt-only
            kali_header_pattern = r'^[┌╭]──.*[\])]$'
            if (re.search(kali_header_pattern, last_block_lines[0]) and
                re.search(r'[$#%❯→➜]\s*$', last_block_lines[1])):
                blocks = blocks[:-1]
            # Or check if it's context command with no output
            elif (re.search(kali_header_pattern, last_block_lines[0]) and
                  re.search(r'[$#%❯→➜]\s+context(\s|$)', last_block_lines[1])):
                blocks = blocks[:-1]

    # Return requested number of blocks
    if count is None:
        return blocks
    else:
        return blocks[-count:]


def format_output(blocks):
    """Format prompt blocks for display"""
    if not blocks:
        return "#c# No prompts found in session recording."

    result = []
    for block in blocks:
        # Prefix each line of the block
        for line in block.split('\n'):
            result.append(f"#c# {line}")
        result.append("#c# ")  # Blank line separator between blocks

    return '\n'.join(result)


def main():
    # Parse arguments
    parser = argparse.ArgumentParser(description='Extract prompt blocks from terminal session')
    parser.add_argument('count', nargs='?', default=1,
                       help='Number of recent prompt blocks to show or "all" for entire history (default: 1)')
    parser.add_argument('-e', '--environment', action='store_true',
                       help='Output SESSION_LOG_FILE environment variable')
    parser.add_argument('-a', '--all', action='store_true',
                       help='Show entire history')

    args = parser.parse_args()

    # Find cast file
    cast_file = find_cast_file()

    # Handle -e/--environment flag
    if args.environment:
        if cast_file:
            export_cmd = f"export SESSION_LOG_FILE='{cast_file}'"
            print(export_cmd)

            # Try to copy to clipboard using xsel (both PRIMARY and CLIPBOARD)
            try:
                # Copy to PRIMARY selection (middle-click paste)
                subprocess.run(
                    ['xsel', '--primary', '--input'],
                    input=export_cmd.encode(),
                    check=True,
                    capture_output=True
                )
                # Copy to CLIPBOARD selection (Ctrl+V paste)
                subprocess.run(
                    ['xsel', '--clipboard', '--input'],
                    input=export_cmd.encode(),
                    check=True,
                    capture_output=True
                )
                print("# Command copied to clipboard", file=sys.stderr)
            except (subprocess.CalledProcessError, FileNotFoundError):
                # xsel not available or failed - silently continue
                pass
        else:
            print("# No asciinema session recording found", file=sys.stderr)
            sys.exit(1)
        return

    # Determine if we want all history
    show_all = args.all or args.count == 'all'

    if show_all:
        count = None  # Signal to show all
    else:
        # Validate count is a number
        try:
            count = int(args.count)
            # Convert negative to positive with a note
            if count < 0:
                count = abs(count)
                print(f"#c# context usage note: Using {count} (converted from negative value)", file=sys.stderr)
            # Still validate that it's not zero
            if count < 1:
                raise ValueError()
        except (ValueError, TypeError):
            print("Error: Please provide a positive number or 'all'", file=sys.stderr)
            parser.print_help(sys.stderr)
            sys.exit(1)

    if not cast_file:
        print("Error: No asciinema session recording found.", file=sys.stderr)
        print("Make sure you're in a shell with asciinema recording enabled.", file=sys.stderr)
        sys.exit(1)

    # Convert to text
    try:
        text = convert_cast_to_text(cast_file)
    except subprocess.CalledProcessError as e:
        print(f"Error: Failed to convert cast file: {e}", file=sys.stderr)
        sys.exit(1)
    except FileNotFoundError:
        print("Error: asciinema command not found. Is it installed?", file=sys.stderr)
        sys.exit(1)

    # Extract prompt blocks
    blocks = extract_prompt_blocks(text, count)

    # Display results
    print(format_output(blocks))


if __name__ == "__main__":
    main()
