#!/usr/bin/env python3
"""
Context - Extract terminal history from asciinema session recordings

Extracts prompt blocks (prompt + command + output) from your terminal session.
Each block contains everything from one prompt to the next, preserving the exact
terminal formatting including multi-line commands.

Usage:
    context          # Show last prompt block (default)
    context 5        # Show last 5 prompt blocks
    context all      # Show entire session
    context -a       # Show entire session
    context -e       # Output SESSION_LOG_FILE environment variable
Usage:
    context [number|all]
    context -a | --all
    context -e | --environment
Example:
    context 5 (shows last 5 prompt blocks)
    context all (shows entire history)
    context -a (shows entire history)
    context -e (outputs export command for SESSION_LOG_FILE)
"""

import os
import sys
import subprocess
import tempfile
import re
import argparse


def find_cast_file():
    """Find the current session's cast file"""
    # First, check environment variable
    if "SESSION_LOG_FILE" in os.environ:
        cast_file = os.environ["SESSION_LOG_FILE"]
        if os.path.exists(cast_file):
            return cast_file

    # Fall back to finding most recent cast file in log directory
    log_dir = os.environ.get("SESSION_LOG_DIR", "/tmp/session_logs/asciinema")
    if not os.path.exists(log_dir):
        return None

    cast_files = [
        os.path.join(log_dir, f)
        for f in os.listdir(log_dir)
        if f.endswith(".cast")
    ]

    if not cast_files:
        return None

    # Return most recently modified file
    return max(cast_files, key=os.path.getmtime)


def convert_cast_to_text(cast_file):
    """Convert .cast file to readable text using asciinema"""
    with tempfile.NamedTemporaryFile(mode='w+', suffix='.txt', delete=False) as tmp:
        tmp_path = tmp.name

    try:
        subprocess.run(
            ["asciinema", "convert", cast_file, tmp_path, "--overwrite"],
            check=True,
            capture_output=True
        )

        with open(tmp_path, 'r', encoding='utf-8', errors='replace') as f:
            content = f.read()

        return content
    finally:
        if os.path.exists(tmp_path):
            os.unlink(tmp_path)


def detect_prompts(text):
    """
    Detect command prompts in the text.
    Returns list of (line_number, line_content) tuples for lines that are prompts.

    Detects various prompt formats:
    - Lines ending with $ or # (standard bash/sh prompts)
    - Lines containing user@host patterns
    - Lines with common zsh theme markers (%, ❯, →, etc.)
    """
    lines = text.split('\n')
    prompt_lines = []

    # Common prompt patterns
    prompt_patterns = [
        r'.*[$#]\s*$',           # Ends with $ or # (standard bash/sh)
        r'.*[$#]\s+\S+',          # $ or # followed by command
        r'(?<!\d)[%❯→➜]\s*$',     # Zsh themes (%, ❯, →, ➜) - not after digit
        r'(?<!\d)[%❯→➜]\s+\S+',   # Zsh themes followed by command - not after digit
        r'^\S+@\S+.*[$#%]',       # user@host pattern with prompt char
    ]

    for i, line in enumerate(lines):
        # Skip empty lines
        if not line.strip():
            continue

        # Check against patterns
        for pattern in prompt_patterns:
            if re.search(pattern, line):
                prompt_lines.append((i, line))
                break

    # Handle Kali/fancy two-line prompts (header line + prompt line)
    # Example: ┌──(kali㉿kali)-[~/dir]
    #          └─$ command
    adjusted_prompt_lines = []
    kali_header_pattern = r'^[┌╭]──.*[\])]$'

    for line_num, line_content in prompt_lines:
        # Check if previous line is a Kali-style header
        if line_num > 0 and re.search(kali_header_pattern, lines[line_num - 1]):
            # Start block at header line instead
            adjusted_prompt_lines.append((line_num - 1, lines[line_num - 1]))
        else:
            adjusted_prompt_lines.append((line_num, line_content))

    return adjusted_prompt_lines


def should_exclude_block(block):
    """
    Check if a prompt block should be excluded from output.

    Excludes blocks where the command starts with:
    - context (with space or end of string)
    - llm (with space)
    - aichat (with space or end of string)
    - llm-sidechat (with space or end of string)

    Args:
        block: Text block containing prompt + command + output

    Returns:
        True if block should be excluded, False otherwise
    """
    if not block:
        return False

    # Split into non-empty lines
    lines = [line for line in block.split('\n') if line.strip()]

    if not lines:
        return False

    # Check if this is a Kali-style two-line prompt
    kali_header_pattern = r'^[┌╭]──.*[\])]$'
    command_line_idx = 0

    if len(lines) >= 2 and re.search(kali_header_pattern, lines[0]):
        # Skip the decorative header, use second line
        command_line_idx = 1

    if command_line_idx >= len(lines):
        return False

    command_line = lines[command_line_idx]

    # Extract the command after the prompt character
    # Prompt patterns: $ # % ❯ → ➜
    prompt_chars = r'[$#%❯→➜]'
    match = re.search(f'{prompt_chars}\\s+(.+)', command_line)

    if not match:
        # No command found (just a prompt), don't exclude
        return False

    # Get the command and strip leading/trailing whitespace
    command = match.group(1).strip().lower()

    # Check if command starts with any of our filtered patterns
    filtered_patterns = [
        'context ',  # context with space
        'context',   # context at end of line (no args)
        'llm ',      # llm with space (all subcommands)
        'aichat ',   # aichat with space
        'aichat',    # aichat at end of line
        'llm-sidechat ',  # llm-sidechat with space
        'llm-sidechat',   # llm-sidechat at end of line
    ]

    for pattern in filtered_patterns:
        if command.startswith(pattern):
            return True

    return False


def extract_prompt_blocks(text, count=1):
    """
    Extract prompt blocks (prompt + command + output) from the converted text.

    Args:
        text: Converted asciinema text
        count: Number of recent prompt blocks to extract (None for all)

    Returns:
        List of text blocks, each containing everything from one prompt to the next
    """
    lines = text.split('\n')
    # Filter out lines from previous context command outputs
    lines = [line for line in lines if not line.lstrip().startswith('#c#')]
    prompt_lines = detect_prompts('\n'.join(lines))

    if not prompt_lines:
        return []

    blocks = []

    # Process each prompt line - extract everything from this prompt to the next
    for i, (line_num, prompt_line) in enumerate(prompt_lines):
        # Get all lines from this prompt to the next prompt (or end of text)
        start_line = line_num
        if i + 1 < len(prompt_lines):
            end_line = prompt_lines[i + 1][0]
        else:
            end_line = len(lines)

        block_lines = lines[start_line:end_line]
        block = '\n'.join(block_lines).rstrip()

        # Only append if this block should not be excluded (filter AI commands)
        if not should_exclude_block(block):
            blocks.append(block)

    # Exclude the last block if it's just an empty current prompt
    # or if it's a self-referential context command with no output yet
    if blocks:
        last_block_lines = [line for line in blocks[-1].split('\n') if line.strip()]

        if not last_block_lines:
            # Completely empty block
            blocks = blocks[:-1]
        elif len(last_block_lines) == 1:
            # Single-line prompt: check if it's just a prompt with no command
            if re.search(r'[$#%❯→➜]\s*$', last_block_lines[0]):
                blocks = blocks[:-1]
            # Or check if it's context command with no output
            elif re.search(r'[$#%❯→➜]\s+context(\s|$)', last_block_lines[0]):
                blocks = blocks[:-1]
        elif len(last_block_lines) == 2:
            # Potential two-line prompt (Kali/fancy prompts)
            # Check if first line is header and second is prompt-only
            kali_header_pattern = r'^[┌╭]──.*[\])]$'
            if (re.search(kali_header_pattern, last_block_lines[0]) and
                re.search(r'[$#%❯→➜]\s*$', last_block_lines[1])):
                blocks = blocks[:-1]
            # Or check if it's context command with no output
            elif (re.search(kali_header_pattern, last_block_lines[0]) and
                  re.search(r'[$#%❯→➜]\s+context(\s|$)', last_block_lines[1])):
                blocks = blocks[:-1]

    # Return requested number of blocks
    if count is None:
        return blocks
    else:
        return blocks[-count:]


def format_output(blocks):
    """Format prompt blocks for display"""
    if not blocks:
        return "#c# No prompts found in session recording."

    result = []
    for block in blocks:
        # Prefix each line of the block
        for line in block.split('\n'):
            result.append(f"#c# {line}")
        result.append("#c# ")  # Blank line separator between blocks

    return '\n'.join(result)


def main():
    # Parse arguments
    parser = argparse.ArgumentParser(description='Extract prompt blocks from terminal session')
    parser.add_argument('count', nargs='?', default=1,
                       help='Number of recent prompt blocks to show or "all" for entire history (default: 1)')
    parser.add_argument('-e', '--environment', action='store_true',
                       help='Output SESSION_LOG_FILE environment variable')
    parser.add_argument('-a', '--all', action='store_true',
                       help='Show entire history')

    args = parser.parse_args()

    # Find cast file
    cast_file = find_cast_file()

    # Handle -e/--environment flag
    if args.environment:
        if cast_file:
            export_cmd = f"export SESSION_LOG_FILE='{cast_file}'"
            print(export_cmd)

            # Try to copy to clipboard using xsel (both PRIMARY and CLIPBOARD)
            try:
                # Copy to PRIMARY selection (middle-click paste)
                subprocess.run(
                    ['xsel', '--primary', '--input'],
                    input=export_cmd.encode(),
                    check=True,
                    capture_output=True
                )
                # Copy to CLIPBOARD selection (Ctrl+V paste)
                subprocess.run(
                    ['xsel', '--clipboard', '--input'],
                    input=export_cmd.encode(),
                    check=True,
                    capture_output=True
                )
                print("# Command copied to clipboard", file=sys.stderr)
            except (subprocess.CalledProcessError, FileNotFoundError):
                # xsel not available or failed - silently continue
                pass
        else:
            print("# No asciinema session recording found", file=sys.stderr)
            sys.exit(1)
        return

    # Determine if we want all history
    show_all = args.all or args.count == 'all'

    if show_all:
        count = None  # Signal to show all
    else:
        # Validate count is a number
        try:
            count = int(args.count)
            if count < 1:
                raise ValueError()
        except (ValueError, TypeError):
            print("Error: Please provide a positive number or 'all'", file=sys.stderr)
            parser.print_help(sys.stderr)
            sys.exit(1)

    if not cast_file:
        print("Error: No asciinema session recording found.", file=sys.stderr)
        print("Make sure you're in a shell with asciinema recording enabled.", file=sys.stderr)
        sys.exit(1)

    # Convert to text
    try:
        text = convert_cast_to_text(cast_file)
    except subprocess.CalledProcessError as e:
        print(f"Error: Failed to convert cast file: {e}", file=sys.stderr)
        sys.exit(1)
    except FileNotFoundError:
        print("Error: asciinema command not found. Is it installed?", file=sys.stderr)
        sys.exit(1)

    # Extract prompt blocks
    blocks = extract_prompt_blocks(text, count)

    # Display results
    print(format_output(blocks))


if __name__ == "__main__":
    main()
